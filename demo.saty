@import: ac-cls
@require: itemize
@require: color
@require: uline/uline
@require: image/image
@require: texlogo/texlogo
@require: ruby/ruby
@require: code
@import: fonts



AC.document '<
  +p{筑波大学AC入試で使った自己推薦書用クラスファイルのデモファイルです。}
  +p{自己推薦書の本文の一部を残しています。}
  +p{}
  +p{}
  +p{ちなみに、下のチャート図の通りにはなっていません。公開したくない箇所は削除しているので。}
> '<
  +chapter {OSS活動} <
    +section {\SATySFi;でのカスタマイズが容易なクラスファイルの作成について} <
      +p{中三学年の時に行われた「Y2b」という論文作成課題の際、「\SATySFi;でのカスタマイズが容易なクラスファイルの作成」というテーマで研究を行い、発表を行った。}
      +p{\ruby?:[Ruby.mode Ruby.g][`サティスファイ`]{|\SATySFi;|}は「\LaTeX;よりも良い組版ソフトウェアを作る」を目標に作成されている組版ソフトウェアで、2017年度IPA未踏事業により開発された。現在もGitHub上で開発が続けられている。発音は英単語の"satisfy"と同じである。}
      +p{この\SATySFi;というソフトウェアで文書を作る際には、\LaTeX;と同じように「クラスファイル」と呼ばれる、「文章構造や、フォント・デザイン・版面設計などのレイアウトに関する設定をするライブラリ」が必要となる。}
      +p{\LaTeX;のクラスファイルでは設定を豊富に行うことができ、さらに各種パッケージを使うことでレイアウトに関する高度な変更ができるようになっている。しかし\SATySFi;で当時提供されていたクラスファイルはそのような設定をすることができず、用紙サイズをA4からB5に変更したいだけでクラスファイルを一から作らなければならないような状況であった。}
      +p{そこで、「文書を書く人が文書の用途によって容易に版面などのデザインを変更できるようにする」クラスファイルを作成しようと考えた。}
      +p{まず、\LaTeX;のクラスファイルでどのようなオプションがあるかをドキュメントを読んで調査した。また、\LaTeX;でデザインやレイアウトを変更できるパッケージを検索し、どのような部分を変更する需要があるのかについて調査した。}
      +p{\SATySFi;では特別な設定をしなければ値の上書きをできない。また、そもそもとしてレイアウトやデザインに関わる部分はクラスファイルが責任をもって管理するべき部分である。そのため、\LaTeX;のような外部パッケージによる上書きでのレイアウトの変更は採用せず、クラスファイルで全て操作できるようにした。変更したいパラメータについて案を固めた後に、パラメータに値を渡す方法について考えた。その結果、
      \listing{
        * 既存のクラスファイルを踏襲し、文書を作るmain関数にパラメータを引数の形で渡して実現する
        * わかりやすいようにスタイル・デザイン・フォントなどにパラメータの要素を分割する
        * パラメータに与える値を定数としていくつか用意しておき、用途に応じて使いまわせるようにする
      }という仕様に落ち着いた。この結果、今まであったクラスファイルと似たような使い勝手な上に細かく制御ができ、さらに一度スタイルを決めたものを使いまわせるようになる、という非常に使いやすい形となった。}
      +p{上記のように仕様が固まったのでこれを実装した。その際、既存のクラスファイルの実装を参考にしながら実装した。この時、パラメータの値を取り出すときに苦労をした。結局、事前にダミーの値を用意しておき、それを内部で上書きをするという方法をとった。}
      +p{用紙サイズをA4にするスタイルやB5にするスタイル、レポート用のデザインや文書用のデザインなど、様々なスタイルをデフォルトで用意しておいたため、文書作成者が用途に応じて容易に版面やデザインを変更できるようになり、当初の目標である、「文書を書く人が文書の用途によって容易に版面などのデザインを変更できるようにするクラスファイルを作成する」という目標を達成した。}
      +p{実装したものは"ExDesign"という名前でGitHubリポジトリ\cite[`exdesign`];で公開・配布している。}
      +figure {exdesignのGitHubリポジトリ\cite[`exdesign`];} <
        +center{\include-image(`fig/exdesign-repository.JPG`);}
      >
    >
    +section {\SATySFi;本体への機能追加} <
      +p{\SATySFi;の拡張機能を作成するだけではなく、\SATySFi;本体に機能追加の提案をし、取り込まれたものがいくつかある。ここではそれを紹介する。}
      +subsection {`string-explode`関数の追加} <
        +p{\SATySFi;では文字は「文字列」としてしか扱うことができず、文字単体を表す表現が無かった。また、文字の比較を行う機能も無かった。そのため、文字列をkeyとしたsortを行うこともできず、文字列の評価もあまり上手くできていなかった。}
        +p{これを解消するため、文字列をUnicodeポイント列に変換するプリミティブを実装し、それを追加する提案を行った。既に「\SATySFi;での文字列を実装言語での文字単位ごとに分割する関数」と「文字単位をUnicodeポイントに変換する関数」が実装として用意されていたため、これを組み合わせることで実現することができた。}
        +p{関数追加の提案は\SATySFi;のGitHubリポジトリで行った。\cite[`pull#202`];}
        +figure ?:(`pull202`) {Pull Request \#202\cite[`pull#202`];} <
          +center{\include-image(`fig/pull-202.JPG`);}
        >
        +p{このプリミティブが追加されたことで以下のような拡張機能を作成することができるようになった。
        \listing{
          * 文字列の比較関数の実装\cite[`pull#127`];
          * 文字列から漢数字・ローマ数字への変換関数の実装\cite[`num-conversion`];
        }}
        +figure {Pull Request \#127\cite[`pull#127`];} <
          +center{\include-image(`fig/pull-127.JPG`);}
        >
        +figure {Pull Request \#127での`string-explode`の使い場所\cite[`pull#127`];} <
          +center{\include-image(`fig/pull-127-files.JPG`);}
        >
        +figure {num-conversionでの`string-explode`の使い場所\cite[`num-conversion`];} <
          +center{\include-image(`fig/num-conversion-code.JPG`);}
        >
      >
    >
    +section {\SATySFi;のライブラリの作成} <
      +p{\SATySFi;は組版層とプログラミング層に機能が分かれている、どちらに対しても拡張機能をユーザーが用意することができる。私は今まで25種類以上もの拡張機能を作成し、ライブラリとして公開・配布している。その中でも特に記憶に強く残っているものを紹介する。}
      +subsection {satysfi-rubyの作成} <
        +p{小説を作成する際にルビ（振り仮名）は必要となってくる。ルビはHTMLの規格にも`<ruby>`タグとして実装されているほど国際的にメジャーなものになっている。\SATySFi;で小説を書こうと思った人にとって、ルビを振る機能が無いことがハードルにならないようにルビを振る機能を実装することにした。}
        +p{ルビを振るコマンドの仕様を決める際には、日本語の組版処理の例示と解説をW3Cが公開している「日本語組版処理の要件(JLreq)」というものを参考にした。JLreqの中に「ルビと圏点処理」という節が設けられており、そこに詳しくまとめられていた。\cite[`ruby-page`];}
        +p{JLreqによるとルビには、漢字一文字に対してその漢字の読み方を振る「モノルビ」と、熟字訓のように分割できない一単語に対してその読み方を振る「グループルビ」、そして熟語一つに対してその熟語の読み方を振る「熟語ルビ」の3種類があるとされている。}
        +figure {モノルビの例} <
          +center{\include-image(`fig/ruby-mono-demo.JPG`);}
        >
        +figure {グループルビの例} <
          +center{\include-image(`fig/ruby-group-demo.JPG`);}
        >
        +p{熟語ルビは「\ruby ?:[Ruby.mode Ruby.j] ([`りゆう`;`ぎ`]){|流|儀|}」のような、漢字ごとの読みの長さが極端に違う場合に、漢字間に余計なスペースが入らないようにルビを違う漢字にかかるように調節する振り方をするものである（この場合、モノルビであると「\ruby ?:[Ruby.mode Ruby.m] ([`りゆう`;`ぎ`]){|流|儀|}」となり、「流」と「儀」の間にスペースが入ってしまう。）。}
        +figure {左のモノルビと右の熟語ルビとの文字間スペースの比較} <
          +center{\include-image(`fig/ruby-jukugo-demo.JPG`);}
        >
        +p{ルビを振るためのコマンドの入力は統一して「漢字一文字ずつのリスト」と「漢字一文字に対応する読みのリスト」の2つを引数とした。オプションでルビの種類を切り替えたり、左右のスペースを調節できるようにした。このインターフェースは\LaTeX;でルビ機能を提供するパッケージである"PXrubrica"パッケージのそれを参考にした。}
        +p{モノルビは次のように実装した。}
        +p{まず、2つの引数を基にルビと漢字をペアにしたリストを作成する。次にルビ部分と漢字部分を自然に組む。そしてその組んだ結果の横の長さを計測する。そしてその長さをそれぞれ比較し、ルビ文字の方が短い場合には漢字一文字に対して中央揃えの位置にスペースを調節して出力する。ルビ文字の方が長い場合はその逆にルビ文字に対して漢字の方を中央揃えとする。}
        +p{グループルビは次のように実装した。}
        +p{まず、モノルビと同じようにルビと漢字をペアにしたリストを作成する。そしてルビ部分と漢字部分を自然に組み、長さを計測する。その後ルビ部分が短い場合にはルビ同士の間にスペースを、漢字部分が短い場合には漢字同士の間にスペースを入れることでルビ部分と漢字部分の横の長さが揃うようにする。その際、見栄えを整えるために均一にスペースを割り振るのではなく、両端のスペースの大きさが文字間のスペースの大きさの丁度半分になるように調節する。}
        +p{JRLeqでは熟語ルビの実装方法について、熟語の構成やその熟語の前後に来る文字で振り仮名の振り方やスペースを調節する方法と、「日本語文書の組版方法」という名称のJISの規格である“JIS X 4051”に規定された方法の2通りが挙げられている。\SATySFi;では前後の文字を取得する方法がないため、"JIS X 4051"で規定された方法で実装することとした。}
        +p{"JIS X 4501"では「ルビが漢字よりも長い文字が一文字でもある」場合と、そうでない場合とに分けて処理を行うことと規定されている。「ルビが漢字よりも長い文字が一文字でもある」場合にはグループルビと同じように組み、そうでない場合には熟語ルビと同じように組むように規定されている。そのため、それに従い、ルビ部分と漢字部分を一旦組んでそれぞれの長さを計測し、その長さを比較した後に、モノルビとグループルビに処理を振り分けるように実装した。}
        +p{各ルビの種類ごとに処理方法は以上のように実装したが、ルビ部分を漢字部分の上に素直に載せる処理を行うと、「一」などの高さがあまりない漢字の部分だけルビの位置が下がってしまい、見栄えがとても悪くなる。そのため、漢字部分を組んだ後に全ての漢字について高さの計測を行い、一番高いところにルビの高さが揃うようにブロックを挿入するという調節処理を行っている。}
        +figure {高さの揃わないルビの例} <
          +center{\include-image(`fig/ruby-pad-test.JPG`);}
        >
        +figure {高さを調節した後のルビの例} <
          +center{\include-image(`fig/ruby-control.JPG`);}
        >
        +p{このライブラリにはルビを組む以外にも調節機能が備わっている。例えば、ルビ部分が漢字部分よりも大きくはみ出している場合には前後の文字にルビ部分をはみ出させることができるとJLReqには書かれている。\SATySFi;では前後の文字を取得することができないため、ここは使用者がオプションで手動で行えるようにした。}
        +p{このルビを振るためのライブラリは"satysfi-ruby"としてGitHubで公開・配布した。\cite[`satysfi-ruby`];
        また、私の運営しているブログにも\SATySFi;でルビ振り機能を実装した話を記事として公開した。\cite[`ruby-blog`];}
        +figure {satsyfi-rubyのリポジトリ} <
          +center{\include-image(`fig/ruby-repository.JPG`);}
        >
      >
      +subsection {satsyfi-jsonの作成} <
        +p{satysfi-jsonは\SATySFi;で実装されたJSONとJSON5のパーサとデコーダである。}
        +p{JSONとはデータ形式フォーマットの一つである。Webアプリの作成でデータの受け渡しをする際によく使われるほか、ソフトウェアの設定などにも使われる。\SATySFi;でもフォントファイルのデータや相互参照のためのダンプファイルの形式として採用されている。とてもメジャーで一般的なものであり、この世界で実際に利用されているプログラミング言語のほとんどでJSON形式をパースするライブラリが実装されていると言っても過言ではない。JSONの規格は\url(`json.org`);に書かれている。}
        +p{現在\SATySFi;では相互参照には文字列しか埋め込むことができない。そのため、数字や真偽値、データを埋め込むことや逆にそのようなデータを取り出すことができない。真偽値を埋め込み、取り出したいが、これができないために困ったことがあった。そこで、数字や真偽値を埋め込む機能を\SATySFi;本体に導入することを提案したことがあった。しかし、\SATySFi;の作者から"It seems to me that they should be implemented as ordinary user- or package-level functions, not provided as primitives\; it would be simpler to make users or packages responsible for encoding/decoding values (by using satysfi-base, for example) than to add somewhat duplicated primitives."\cite[`issue#220`];と返答があり、この機能の実装を断念した。結局この問題はライブラリ上で数字や真偽値のパーサを実装することで解決したが、\SATySFi;でJSONパーサとデコーダを実装していればより汎用的なデータを取り扱うことができることに気が付いた。そこで、これを実装した。}
        +figure {issue\#220のスクリーンショット\cite[`issue#220`];} <
          +center{\include-image(`fig/issue-220.JPG`);}
        >
        %+p{JSONは、波括弧(`{}`)で囲まれた名前と値のペアの集合である「オブジェクト」・角括弧(`[]`)で囲まれた値の配列・文字列や数字、真偽値などの値の3つで構成されている。}
        +p{\SATySFi;では文字列を一文字ずつ分解して扱う方法があることと、JSONの文字列と数字の表現が複雑なこと、そしてJSONの文法が左再帰となっておらず、左再帰下降パーサで処理できることから、手書きlexerによってJSON文字列をトークン化し、そのトークンリストを手書きの左再帰下降パーサで解析して\SATySFi;のデータ構造に落とし込むという方法を採用した。}
        +p{lexerは文字列からトークン列を生成する関数である。文字列を頭から一文字ずつ読みこんで変換していく。読み込んだ文字によっては複数文字先読みして複数の文字列にしてから変換することもある。トークンは
        \listing{
          * Comma（"`,`"のこと）
          * Colon（"`:`"のこと）
          * LeftCurlyBracket（"`{`"のこと）
          * RightCurlyBracket（"`}`"のこと）
          * LeftSquareBracket（"`[`"のこと）
          * RightSquareBracket（"`]`"のこと）
          * Null（"`null`"のこと）
          * True（"`true`"のこと）
          * False（"`false`"のこと）
          * Int of int（整数を表す）
          * Float of float（小数を表す）
          * String of string（文字列を表す）
        }の12個用意した。}
        +p{lexerは再帰関数で実装した。引数は「トークンのリスト」・「エラーメッセージ使用する文字の位置情報」・「文字のリスト」の3つである。終了条件は文字のリストが空になるまで、である。}
        +p{空白文字は無視するように規定されているため、規格の上で空白文字とされている"space" ・"Horizontal Tab"・"Carriage Return"・"LineFeed"の4種類の文字のいずれかを読み込んだときには、その文字だけ消費し、文字位置を1つ進めるだけとした。}
        +p{一文字をあらわすトークン（`Comma`や`LeftCurlyBracket`、`RightSquareBracket`などである）については、該当する文字が現れた時には、対応するトークンをトークンのリストに追加し、その文字を消費し、文字位置も一つ進める。}
        +p{`null`・`true`・`false`の3つについては、まず、現れた文字がアルファベットであった場合に、次の文字がアルファベットでは無くなるまで文字の取得を行い続ける。次に、取得した文字をつなげ、それらが`null`・`true`・`false`のいずれかであった場合には該当するトークンへと変換し、トークンのリストに追加する。3つのいずれでも無かった場合はエラーとする。最後に文字位置と文字のリストをアルファベット文字列を取得した後のものに更新し、lexerの再帰関数に渡すようにした。}
        +p{JSONでの文字列の表記法は基本的に単純ではあるものの、エスケープされた文字列の扱いがやや面倒であった。}
        +figure {文字列の構文を表した図\cite[`json-org`];} <
          +center{\include-image(`fig/json-bnf-string.JPG`);}
        >
        +p{文字列はダブルクオーテーション(`"`)から始まり、ダブルクオーテーションで終わる。そのため、読み込んだ文字がダブルクオーテーションであった場合は、次にダブルクオーテーションが現れるまで、出てきた文字を全てstackに保存し、ダブルクオーテーションが現れた時に、保存していた文字列を`String`トークンとするという実装をした。ただし、バックスラッシュ(`\`)が現れた場合は、文字列のエスケープモードに入るため、特殊な実装を必要とする。上の図にあるように、バックスラッシュの後に
        \listing{
          * `"`
          * `\`
          * `/`
          * `b`
          * `f`
          * `n`
          * `r`
          * `t`
        }が現れた場合は、それに対応する文字や特殊文字に置き換えてstackに保存しなければならない。このとき、文字列位置は二つ移動させ、文字のリストも当然2つ消費する。また、バックスラッシュのあとに`u`があり、さらにその後に「0から9までの数字、もしくはAからF、もしくはaからfのアルファベット」が4つ並んでいた場合は、その4つの文字を16進数表記と見た時の数字をUnicodeポイントとして持っている文字をstackに保存する。この時は文字位置を6つ進め、文字を6つ消費することになる。もし、`\u`の後に「0から9までの数字、もしくはAからF、もしくはaからfのアルファベット」が4つ並んでいなかった場合\footnote{例えば3つしか並んでおらず、4つ目には"X"という文字が来ていた場合など}はエラーを返すようにする。}
        +p{整数と小数はJSON規格の上ではnumberとされ、同じものとして扱われている。しかし、\SATySFi;は整数と小数を型レベルで分けているため、satysfi-jsonは\SATySFi;の設計に従い、整数と小数に分けてデータを取得する。数字の表記は下の図\ref(`json-number`);のように定められている。}
        +figure ?:(`json-number`) {数字表現の構文を表した図\cite[`json-org`];} <
          +center{\include-image(`fig/json-bnf-number.JPG`);}
        >
        +p{数字かマイナス記号のどちらかが現れたときにnumberの解析に入る。まず数字が続く限り文字を取得し続ける。その後、次の文字が小数点かどうかで分岐が発生する。小数点があった場合は、その後に続く数字を取得する。その後に指数表記があるかどうかをチェックし、指数表記があった場合にはその部分も取得する。そして数字の列と小数点を結合してパースし、小数に変換する。指数表記があった場合にはその計算も行う。小数点がなかった場合は指数表記のチェックに入り、あった場合には同様に取得する。そして文字列をパースして整数に変換した後に、指数部分の計算を行う。}
        +p{これで全ての表記規則をトークンに変換することができた。次は、こうして出来上がったlexerを通して作成したトークン列をパースし、\SATySFi;上のデータ構造に変換する。\SATySFi;でのデータ構造は
        \d-code(`
type json =
  | Null
  | Bool of bool
  | Int of int
  | Float of float
  | String of string
  | Array of json list
  | Object of (string * json) list
        `);で定義される再帰型である。}
        +p{パーサは1つ先読みの再帰下降構文解析法（LL(1)法とも呼ばれる）で実装する。この解析方法は、トークン列を左側から1つずつ読んでいくことで解析でき、バックトラックなどを行わないで効率的に解析できる方法として知られている。}
        +p{\SATySFi;は相互再帰関数を定義することができるため、今回作成するLL(1)パーサの実装が容易であった。}
        +p{まず、valueとJSONの規格で呼ばれているものをパースする関数を作成した。}
        +figure {valueの構文を表した図\cite[`json-org`];} <
          +center{\include-image(`fig/json-bnf-value.JPG`);}
        >
        +p{ここではトークンとしての
        \listing{
          * `String`
          * `Int`
          * `Float`
          * `True`
          * `False`
          * `Null`
        }が現れた時に、それに対応するデータ構造に中身を移し、データ構造列に加える処理を行う。
        また、`object`と`array`の解析のために、トークン`LeftSquareBracket`と`LeftCurlyBracket`のどちらかが現れた時に、相互再帰関数として同時に定義している「arrayを解析する再帰関数」と「objectを解析する再帰関数」をそれぞれ呼び出すようにした。}
        +p{arrayの定義は下の図のようになっている。}
        +figure {配列の構文を表した図\cite[`json-org`];} <
          +center{\include-image(`fig/json-bnf-array.JPG`);}
        >
        +p{arrayを解析する関数には、"`[`"が既に消費された時点のトークンのリストが渡される。また、whitespaceはトークンに変換する時点で取り除かれているため、考えなくて良い。まず、「valueを解析する再帰関数」を呼び出し、valueとして扱われるデータと、valueを解析した後に残るトークンのリストの2つのデータを作成する。残ったトークン列の先頭が"`]`"であった時にはarrayが終了したと判定し、関数の処理を終了させる。残ったトークン列の先頭がカンマであった場合にはarrayが続くと判定し、カンマの次のトークンに対して再度「valueを解析する再帰関数」を適用させ、データを取得する。これを終了するまで繰り返す。}
        +p{objectの定義は下の図のようになっている。}
        +figure {objectの構文を表した図\cite[`json-org`];} <
          +center{\include-image(`fig/json-bnf-object.JPG`);}
        >
        +p{これもarrayのときと同様に、"`{`"が既に消費された時点でのトークン列が与えられ、whitespaceは全て除去されている。arrayと同様に処理していくが、arrayの定義がvalue単体であったのとは異なり、stringとコロンとvalueがセットとなっている。これらを順に解析してデータ化する。そして"`}`"が現れるまで、コロンとセットで解析・消費していく。}
        +p{以上のように定義した「valueを解析する再帰関数」・「arrayを解析する再帰関数」・「objectを解析する再帰関数」について、最初に「valueを解析する再帰関数」を呼び出すと、トークンに応じてそれぞれがお互いを呼び出しあい、最終的にトークンが全て消費されて処理が綺麗に終われば解析成功となる。もし途中でトークンが尽きたり、逆に解析が終了したのにもかかわらずトークンが余っているような時には解析が失敗したとしてエラーを返すようにしている。また、予期せぬトークンが現れた時もエラーを返して終了するように定義してある。}
        +p{これでJSONのパーサの実装は終わったが、現在のところ純粋なJSONは制限が多くて使いにくいという評価が世界ではなされている。そのため、その制限を緩和し、機能を拡張させた"JSON5"と呼ばれる規格が流行っている。そのため、今回はJSONのパーサだけではなく、JSON5のパーサも実装することとした。JSON5の公式ページは\url(`https://json5.org/`);である。ここに「どのような拡張がJSONに対してなされているのか」という説明が書かれている。例えば、
        \listing{
          * コメントを使用することができる
          * arrayやobjectでの末尾カンマを許可する
          * 文字列は一重引用符で囲んで表現しても良い
          * 改行文字をエスケープすることで長い文字列を複数行で表すことができる
          * 数字で正負の無限大とNaNを使うことができる
          * 数字をプラス記号で始めることができる
          * オブジェクトのキーが英数字である場合は文字列を使わなくて良い
        }といったものである。コメント・文字列・数字表記部分についてのJSON規格との差異についてはlexerの改修で対応した。そして末尾カンマの許容やオブジェクトのキーについてはパーサに手を加えて対応した。}
        +p{パーサを作成し終えたため、今度は\SATySFi;でJSON・JSON5を表すデータ構造をJSON形式・JSON5形式の文字列に変換するデコーダを実装した。パーサとデコーダが揃うことで、データ形式の入出力が容易になる。文字列のエスケープが難しいだけで、他は再帰的に処理していけば文字列への変換が出来る。}
        +p{作成したJSONパーサがおかしな挙動をしていないかのテストも行った。"Parsing JSON is a Minefield\emoji{💣}"\cite[`json-minefield`];という、JSONパーサのコーナーケースとテストに関するブログを参考にし、そのテストケースが置いてあるリポジトリ\cite[`json-test-repo`];の中身を基にテストを作成した。}
        +p{その結果、「エラーを出さなければならないにもかかわらず受理してしまったケース」が全188件中10件、逆に「受理しなければならないのにもかかわらずエラーを出してしまったケース」が全95件中6件出た。これはとても少ないと言える。「エラーを出さなければならないにもかかわらず受理してしまったケース」の全てが数字の処理と文字列の処理で失敗していた。「受理しなければならないのにもかかわらずエラーを出してしまったケース」の全てがUnicodeポイントで表記された文字の処理での失敗であった。このテストケースは\url(`https://github.com/puripuri2100/SATySFi-json-test`);に置いてある。}
        +p{このパーサーは"SATySFi-json"という名前をつけ、GitHubのリポジトリで公開している。\cite[`satysfi-json`];}
      >
    >
  >

  +chapter {学校活動でのソフトウェア等の作成} <
    +p{インターネット上に出すのが良く無さそうなので削除}
  >

> '<
  +p{あとがきです。}
>
